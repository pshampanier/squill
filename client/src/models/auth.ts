/*********************************************************************
 * THIS CODE IS GENERATED FROM API.YAML BY BUILD.RS, DO NOT MODIFY IT.
 ********************************************************************/
import { formatRegExp, serializable } from "@/utils/serializable";

export const TOKEN_TYPE_VALUES = ["bearer"] as const;
export type TokenType = (typeof TOKEN_TYPE_VALUES)[number];
export const AUTHENTICATION_METHOD_VALUES = ["user_password"] as const;
export type AuthenticationMethod = (typeof AUTHENTICATION_METHOD_VALUES)[number];


/// A username
type Username = string;



/**
 * A security token used for authentication.
 **/
export class SecurityTokens {
  
  /**
   * The access token is a 256-bit random number encoded in hexadecimal.
   **/
  @serializable("string", { required: true, snakeCase: "property" })
  accessToken!: string;
  
  /**
   * The type of the access token (always "Bearer" for now)
   **/
  @serializable("string", { format: formatRegExp(TOKEN_TYPE_VALUES), required: true, snakeCase: "property" })
  accessTokenType!: TokenType;
  
  /**
   * The unique identifier of the client that requested the tokens.
   * The `client_id` is used to identify the application that requested the tokens. This is useful for telemetry
   * purposes, typically to track the usage of the application.
   * The client_id is generated by the client application and is not validated by the server.
   * 
   **/
  @serializable("string", { format: "uuid", required: true, snakeCase: "property" })
  clientId!: string;
  
  /**
   * The number of seconds after which the access token will expire.
   **/
  @serializable("integer", { required: true, min: 0, snakeCase: "property" })
  expiresIn!: number;
  
  /**
   * The refresh token is used to generate new security tokens.
   **/
  @serializable("string", { required: true, snakeCase: "property" })
  refreshToken!: string;
  
  /**
   * The unique identifier of the session that the tokens belongs to.
   * Unlike the `access_token` and `refresh_token` this is not a security token but a session identifier. It is
   * generated when the use logs on and discarded when the user logs out. If the client is disconnected and 
   * reconnect, the `session_id` will be the same while the `access_token` and `refresh_token` will be different.
   * The `session_id` is generated by the server.
   * 
   **/
  @serializable("string", { format: "uuid", required: true, snakeCase: "property" })
  sessionId!: string;
  
  /**
   * The unique identifier of the user that the tokens belongs to.
   **/
  @serializable("string", { format: "uuid", required: true, snakeCase: "property" })
  userId!: string;
  
  constructor(object?: Partial<SecurityTokens>) {
    Object.assign(this, object);
  }
}


/**
 * The credentials used to authenticate a user.
 **/
export class Credentials {
  
  @serializable("string")
  password?: string;
  
  @serializable("string", { required: true })
  username!: Username;
  
  constructor(object?: Partial<Credentials>) {
    Object.assign(this, object);
  }
}


export class Authentication {
  
  @serializable("object", { factory: Credentials, required: true })
  credentials!: Credentials;
  
  @serializable("string", { format: formatRegExp(AUTHENTICATION_METHOD_VALUES), required: true })
  method!: AuthenticationMethod;
  
  constructor(object?: Partial<Authentication>) {
    Object.assign(this, object);
    this.credentials = object?.credentials && new Credentials(object.credentials);
  }
}


/**
 * The request body of the POST /auth/refresh-token endpoint.
 **/
export class RefreshToken {
  
  @serializable("string", { required: true, snakeCase: "property" })
  refreshToken!: string;
  
  constructor(object?: Partial<RefreshToken>) {
    Object.assign(this, object);
  }
}